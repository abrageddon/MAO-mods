#!/usr/bin/python
import sys, os, re, string, subprocess, shutil, random, getpass

def failBuild():
    # Something didn't work. Fail back to compile from scratch.
    if prDebug: sys.stderr.write ("=== Fail Build Attempt ===" +'\n')
    return execBuild([clangExec] +  cmdLine.strip().split(), "Fail Build")

def errorCatch(retCode, cmd, mesg):
    if (retCode != 0):
        sys.stderr.write ('========= Error: '+ mesg +' failed\n'+cmd+'\n\n')
        sys.stderr.write( 'os.getcwd(): '+ os.getcwd() +'\n\n')
        sys.stderr.write( 'cmdLine: '+ cmdLine +'\n\n')
        sys.stderr.write( 'outFile: ' + outFile +'\n')
        sys.stderr.write( 'rawFile: ' + rawFile +'\n')
        sys.stderr.write( 'cachedFile: ' + cachedFile +'\n')
    	sys.stderr.write( 'objFile: ' + objFile +'\n')
        sys.stderr.write( 'binFile: ' + binFile +'\n')
        #TODO failBuild?
        sys.exit(retCode)
    return retCode

def execBuild(cmd, mesg):
    global retCode
    
    if realBuild:
        process = subprocess.Popen(cmd)
        retCode = process.wait()
    return errorCatch(retCode, string.join(cmd,' '), mesg)


def cacheBitcode(output, inFile):    # Build .bc file if there is no cached version
    if ( not os.path.isfile(output) ):        
        if prDebug: sys.stderr.write ("=== To Bitcode Cache ===" +'\n')
        
        buildBc = cmdLine
        buildBc = re.sub(r'\s-o\s+\S+\.o\s',' ', buildBc)
        buildBc = re.sub(r'\s-c\s',' ', buildBc)
        buildBc = re.sub(r'\s-i\s+\S+\s',' ', buildBc)

	if(inFile is None):
            buildBc = [clangExec, '-o', output, '-S', '-emit-llvm'] + buildBc.split()
        else:
	    buildBc = [clangExec, '-o', output, '-S', '-emit-llvm', inFile]

	#TODO remove un needed flags, -I file, 
        
        return execBuild(buildBc,"To Bitcode Cache")
    return retCode


def diversify(output, inFile):
    if doDiv:
        if prDebug: sys.stderr.write ("=== Diversify ===" +'\n\n')
        
        #TODO read from command line and purge after use
        seed = str(random.randint(0,100000))
        percent = str(random.randint(10,50))
        
        tests = ""
        
        #tests += "--plugin=/usr/local/lib/MaoSchedRand-x86_64-linux.so:SCHEDRAND=MultiCompilerSeed["+seed+"]+ISchedRandPercentage["+percent+"]:"
        tests += "--plugin=/usr/local/lib/MaoMOVToLEA-x86_64-linux.so:MOVTOLEA=MultiCompilerSeed["+seed+"]+MOVToLEAPercentage["+percent+"]:"
        tests += "--plugin=/usr/local/lib/MaoNOPInsertion-x86_64-linux.so:NOPINSERTION=MultiCompilerSeed["+seed+"]+NOPInsertionPercentage["+percent+"]:"
        
        #Unrelated tests
        #tests += "CFG=respect_orig_labels[1]:"
        #tests += "--plugin=/usr/local/lib/MaoBackBranchAlign-x86_64-linux.so:BACKBRALIGN:"
        #tests += "--plugin=/usr/local/lib/MaoLoop16-x86_64-linux.so:LOOP16:"
        
        
        divBlob = ["mao", "--mao="+tests+"ASM=o["+output+"]", inFile ]
        
        return execBuild(divBlob, "Diversify")
    return retCode


def linkAndCacheAssemblyBlob(output):
    global retCode
    if not os.path.isfile(output):
        if prDebug: sys.stderr.write ("=== Linking Bitcode Files ===" +'\n\n')

        #TODO change directory to do less file rewriting, might cause cmd line to get too long
        
        inObj = re.findall(r'\s\S+\.[cCsSo]+[pPxX+]*\s', cmdLine)
	#For each obj .o located cached .bc file
        #TODO full dir repacement
        for i,item in enumerate(inObj):
	    if item[-2:] == '.o':
                inObj[i] = cacheDir + "/" + re.sub(r'\.o','.bc',item.strip())
	    elif item[-2:] == '.c':
	        #TODO include other source types
	        inObj[i] = cacheDir + "/" + re.sub(r'\.c','.bc',item.strip())
		cacheBitcode(inObj[i], item.strip())

        blobBc = output + ".bc"
        llvmLink = ["llvm-link", "-S", "-o", blobBc] + inObj
        retCode = execBuild(llvmLink, "Linking Bitcode Files") and retCode
        
        if retCode == 0:
	    return cacheAssembly(output, blobBc);
    return retCode

def cacheAssembly(output, inFile):
    if not os.path.isfile(output):
        if prDebug: sys.stderr.write ("=== Cache Assembly ===" +'\n\n')
        #convert to assembly blob
        #TODO use all cmd line options
        buildFlags = cmdLine

        if doBuildObj:
            buildFlags = re.sub(r'\s*-Qunused-arguments\s*',' ',buildFlags)


        if not doBuildObj or not inFile is None:
            buildFlags = re.sub(r'\s\S+\.[cCsSo]+[pPxX+]*\s',' ',buildFlags)


        #remove all .o files replace with blobS
        #TODO other source types
        buildFlags = re.sub(r'\s-o\s+\S+\s',' ',buildFlags)
        #TODO isolate -c flag
        buildFlags = re.sub(r'\s-c\s',' ',buildFlags)
        buildFlags = re.sub(r'\s-o\s',' ',buildFlags)
        #TODO Remove -l\S+ ; unused with -S


        if doBuildObj:
            if(inFile is None):
                assemble = [gccExec, '-o', output, '-S'] + buildFlags.strip().split()
            else:
                assemble = [gccExec, '-o', output, '-S', inFile]
                #assemble = [gccExec, "-o", output, "-S", inFile] + string.split(buildFlags.strip()," ")
        else:
            assemble = [clangExec, "-o", output, "-S", inFile] + string.split(buildFlags," ")

        if prDebug: sys.stderr.write (string.join(assemble,' ')+'\n\n')
        return execBuild(assemble, "Cache Assembly")
    return retCode



def buildBinFromBlobS(output, inFile):
    if retCode == 0:
        if prDebug: sys.stderr.write ("=== Build Bin From BlobS ===" +'\n\n')
        
        flags = cmdLine
        
        #remove all .o files replace with blobSDiv
	#TODO other source types
        flags = re.sub(r'\s\S+\.[cCsSo]+[pPxX+]*\s',' ',flags)
        flags = re.sub(r'\s-o\s+\S+\s',' ',flags)
        flags = re.sub(r'\s+',' ',flags)

        #TODO figure out how to build final bin
        #buildBin = ['as', "-o", output, inFile] 
        buildBin = [gccExec, '-Wa', "-o", output, inFile] + string.split(flags.strip(),' ')
        #buildBin = [gccExec, "-Wa,-alh,-L", "-o", output, inFile] + string.split(flags.strip(),' ')
        #buildBin = [clangExec, "-o", output, inFile] + string.split(flags,' ')

        return execBuild(buildBin, "Build Bin From BlobS")
    return retCode

def buildBinFromObjs():
    if prDebug: sys.stderr.write ("=== Build Bin From Objs ===" +'\n\n')

    buildBin = cmdLine

    #weird crash, dont understand
    buildBin = re.sub(r'\s*-Qunused-arguments\s*',' ',buildBin)

    buildBin = re.sub(r'\s+',' ',buildBin)

    return execBuild([gccExec] +  buildBin.strip().split(), "Build Bin From Objs")
    


def buildObjFromASM(output, inFile):
    #if (not os.path.isfile(output) ):
        if prDebug: sys.stderr.write ("=== ASM To Obj ===" +'\n')

	buildObj=cmdLine
            
	buildObj=re.sub(r'\s\S+\.[cCsS]+[^o\s]?[pPxX+]*\s',' ',buildObj)
	buildObj=re.sub(r'\s-o\s+\S+\s',' ',buildObj)

        #weird crash, dont understand
    	buildObj = re.sub(r'\s*-Qunused-arguments\s*',' ',buildObj)
        buildObj = re.sub(r'\s+',' ',buildObj)

        buildObj = [gccExec, '-Wa', inFile, '-o', output]+ buildObj.strip().split(' ')

        if prDebug: sys.stderr.write (string.join(buildObj,' ')+'\n\n')
        return execBuild(buildObj,"ASM To Obj")
    #return retCode



def main():
    global clangExec
    global gccExec
    clangExec = 'clang'
    gccExec = 'gcc'
    global retCode
    retCode = 0
    global prDebug
    prDebug=False # output to std err
    global mkdirFlag
    mkdirFlag=True # really make dirs, not just print
    global realBuild
    realBuild=True # really build, not just print
    global doBuildObj
    global doBuildBlob
    global doDiv
    doBuildObj=True
    doBuildBlob=False
    doDiv=True

    # make args a single string
    global cmdLine
    cmdLine = ' '+ string.join(sys.argv[1:], ' ')+' '
    #TODO pullout flags
    #TODO -buildObject explicit flag

    global outFile
    global rawFile
    global cachedFile
    global cacheDir
    global objFile
    global binFile
    global bcFile
    global blobS
    global blobSDiv
    
    if (sys.argv[1] == "-prDebug"):prDebug = True
    
    #TODO pull seed and percent from commandline 
    #if prDebug: sys.stderr.write( "\n" )
    # Pick the correct clang....
    if ('++' in sys.argv[0]):
        clangExec = 'clang++'
        gccExec = 'g++'

    # TODO make portable; raw compile configure
    if ( False #bool(re.search(r'workspace/[^/]+/[^/]+\Z',os.getcwd())) # configure fix
    	 or bool(re.search(r'\s\S+\.[sS]\s',cmdLine)) # skip .s files for now TODO find way to cache
         or bool(re.search(r'\s-E\s',cmdLine)) #Ignore lone preprocessing
         or bool(re.search(r'\s-S\s',cmdLine)) #Ignore lone assembly file; errors in firefox
         or bool(re.search(r'\sconftest\.[ocC]?\s',cmdLine)) #conf exempt
         or bool(re.search(r'/config/?',os.getcwd())) #config folder exempt
         or bool(re.search(r'\s--version\s',cmdLine)) #skip version lookups
         or bool(re.search(r'\s-[vV]\s',cmdLine)) #skip version lookups
         or bool(re.search(r'\s-qversion\s',cmdLine)) #skip version lookups
         or bool(re.search(r'\s-dumpversion\s',cmdLine)) #skip version lookups
         #or bool(re.search(r'\s*ns(ThreadUtils|ProxyRelease|ConsoleService|MemoryImpl|CycleCollector|Array).cpp\s*',cmdLine)) #TODO figure out this firefox bug; maybe need preprocessing step? error including dist/include/nsThreadUtils.h
         #or bool(re.search(r'\s*(ClearOnShutdown|VisualEventTracer).cpp\s*',cmdLine)) #TODO 
        ):
	retCode = execBuild([clangExec] + cmdLine.strip().split(), "Excluded Build")
	sys.exit(retCode)

    # Determine needed files
    # find output file
    outFile = string.join(re.findall(r'\s-o\s+\S+\s', cmdLine), ' ')
    
    doFull=False
    if not bool(re.search(r'\s-o\s',cmdLine)) :
        doFull=True
        inSrc = re.findall(r'\s\S+\.[cCsS]+[^o]?[pPxX+]*\s', cmdLine)
        if len(inSrc) == 1 :
            outFile = re.sub(r'\.[cCsS]+[^o]?[pPxX+]*','.o',os.path.basename(inSrc[0]))
    
    outFile = re.sub(r'\s-o\s','',outFile)
    outFile = os.path.realpath(outFile.strip())

    if doFull:
        rawFile = outFile[:-2]
        binFile = rawFile
        objFile = outFile
    if outFile[-2:] == ".o" : #output is an object
        binFile = ""
        objFile = outFile
        rawFile = outFile[:-2]
    #TODO include .so? .exe? .run? ...
    else : #output is a bin... i guess...
        binFile = outFile
        objFile = ''
        rawFile = outFile
    

    # name cached file
    cachedFile = re.sub(r'/home/'+getpass.getuser()+r'/workspace/','/home/'+getpass.getuser()+r'/workspace/bcache/',rawFile)
    bcFile = cachedFile + ".bc"
    asmFile = cachedFile + ".s"
    blobS = cachedFile + ".blob.s"
    blobSDiv = cachedFile + ".blob.div.s"

    blobSDiv = cachedFile + ".blob.div.s"

    # make path to file if needed
    cacheDir = os.path.dirname(cachedFile)
    if cacheDir != '':
        if not os.path.isdir(cacheDir) :
            if mkdirFlag :
                try:
                    os.makedirs(cacheDir)
                except:
                    pass
            else:
                sys.stderr.write ('mkdir file\'s dir: '+cacheDir +'\n')

            
    # There is an .o output file we want to cache
    if len(objFile) != 0:
        # determine location of cached bitcode
        
        cacheBitcode(bcFile,None)
	
	if doBuildObj :
	    cacheAssembly(asmFile, None)
	    diversify(asmFile+"Div.s", asmFile)
            useS=''
            if doDiv:
                useS = asmFile+"Div.s"
            else:
                useS = asmFile
            buildObjFromASM(objFile, useS)
    
    if  len(binFile) != 0:

        #TODO if compiling from .c to bin, do different build
        
        #if input is .c and input.bc doesn't exist; build input.c bitcode
        #if blob doesnt exist; use input.c as .bc

        if doBuildBlob:
            # Build blob object from bitcode
            linkAndCacheAssemblyBlob(blobS)
        
            #Diversify
	    diversify(blobSDiv, blobS)

            useBlob=''
            if doDiv:
                useBlob = blobSDiv
            else:
                useBlob = blobS

            buildBinFromBlobS(binFile, useBlob)

        else:
	    if prDebug: sys.stderr.write( "buildBinFromObj()\n" )
	    #TODO diversify main? only if theres a .c?
            #cacheBitcode(binFile,None)
	    #cacheAssembly(binFile+".s", binFile)
	    #diversify(binFile+"Div.s", binFile+".s")
            #useBin=''
            #if doDiv:
            #    useBc = binFile+"Div.s"
            #else:
            #    useBc = binFile+".s"
	    buildBinFromObjs()
        

    elif len(outFile) == 0:
        errorCatch(1,'','No Output File')

        
    #if prDebug: sys.stderr.write("ret: "+str(retCode)+ "\n" )
    if prDebug: sys.stderr.write( "\n" )
    sys.exit(retCode)


if __name__ == "__main__":
    main()
